use dep::aztec::macros::aztec;
mod structs;

/**
To deploy on testnet, use the following commands (following the tutorial):
1. Set the environment variable for the node URL:
export NODE_URL=https://aztec-alpha-testnet-fullnode.zkv.xyz
export SPONSORED_FPC_ADDRESS=0x1260a43ecf03e985727affbbe3e483e60b836ea821b6305bea1c53398b986047
2. Create a new wallets:
2a. Create a new wallet for the owner:
aztec-wallet create-account \
    --register-only \
    --node-url $NODE_URL \
    --alias owner-wallet
2b. Create a new wallet for the receiver:
aztec-wallet create-account \
    --register-only \
    --node-url $NODE_URL \
    --alias receiver-wallet
3. Register owner account with FPC:
3a. Register the owner wallet with the FPC:
aztec-wallet register-contract \
    --node-url $NODE_URL \
    --from owner-wallet \
    --alias sponsoredfpc \
    $SPONSORED_FPC_ADDRESS SponsoredFPC \
    --salt 0
3b. Register the receiver wallet with the FPC:
aztec-wallet register-contract \
    --node-url $NODE_URL \
    --from receiver-wallet \
    --alias sponsoredfpc \
    $SPONSORED_FPC_ADDRESS SponsoredFPC \
    --salt 0
4. Deploy accounts (may get error `Timeout awaiting isMined` but that is fine continue with the next step):
4a. Deploy the owner wallet:
aztec-wallet deploy-account \
    --node-url $NODE_URL \
    --from owner-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --register-class
4b. Deploy the receiver wallet:
aztec-wallet deploy-account \
    --node-url $NODE_URL \
    --from receiver-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --register-class
5. Deploy the Token contract (wait for it to be mined on testnet check txhash at http://aztecscan.xyz/):
aztec-wallet deploy \
    --node-url $NODE_URL \
    --from accounts:owner-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --alias token \
    TokenContract \
    --args accounts:owner-wallet WormToken WORM 18 --no-wait
6. Mint tokens to public & private now to call the upcoming functions:
6a. Mint public tokens:
7. Deploy the Wormhole contract (wait for it to be mined on testnet check txhash at http://aztecscan.xyz/):
aztec-wallet deploy \
    --node-url $NODE_URL \
    --from accounts:owner-wallet \
    --payment method=fpc-sponsored,fpc=contracts:sponsoredfpc \
    --alias wormhole \
    Wormhole \
    --args 13 13 *receiver address* *token contract address* --no-wait
*/

#[aztec]
pub contract Wormhole {
    use crate::structs::{Provider, Guardian, WormholeStorage, Signature};
    use dep::keccak256::keccak256;

    use dep::aztec::{
        macros::{
            functions::{initializer, public, private, internal, utility},
            storage::storage,
        },
        prelude::{Map, PublicMutable, AztecAddress},
        protocol_types::traits::ToField
    };

    use dep::token::Token; 

    #[utility]
    unconstrained fn get_hardcoded_guardians() -> [crate::structs::Guardian; 19] {
        [
            crate::structs::Guardian::new([0xbe, 0xfa, 0x42, 0x9d, 0x57, 0xcd, 0x18, 0xb7, 0xf8, 0xa4, 0xd9, 0x1a, 0x2d, 0xa9, 0xab, 0x4a, 0xf0, 0x5d, 0x0f, 0xbe], [0xd4, 0xa4, 0x62, 0x99, 0x79, 0xf0, 0xc9, 0xfa, 0x0f, 0x0b, 0xb5, 0x4e, 0xdf, 0x33, 0xf8, 0x7c, 0x8c, 0x5a, 0x1f, 0x42, 0xc0, 0x35, 0x0a, 0x30, 0xd6, 0x8f, 0x7e, 0x96, 0x70, 0x23, 0xe3, 0x4e], [0x49, 0x5a, 0x8e, 0xbf, 0x51, 0x01, 0x03, 0x6d, 0x0f, 0xd6, 0x6e, 0x3b, 0x0a, 0x8c, 0x7c, 0x61, 0xb6, 0x5f, 0xce, 0xea, 0xf4, 0x87, 0xab, 0x3c, 0xd1, 0xb5, 0xb7, 0xb5, 0x0b, 0xeb, 0x79, 0x70]),
            crate::structs::Guardian::new([0x88, 0xd7, 0xd8, 0xb3, 0x2a, 0x91, 0x05, 0xd2, 0x28, 0x10, 0x0e, 0x72, 0xdf, 0xfe, 0x2f, 0xae, 0x07, 0x05, 0xd3, 0x1c], [0xde, 0x95, 0x44, 0xa0, 0x79, 0x98, 0x8d, 0xf1, 0x0b, 0x0c, 0x84, 0x7a, 0x40, 0x18, 0x62, 0xb6, 0x2d, 0x80, 0x74, 0xb0, 0x2b, 0x99, 0x4e, 0xd5, 0xa4, 0xf9, 0x6e, 0x60, 0x78, 0xee, 0x04, 0x8b], [0xd5, 0xfd, 0x0b, 0x55, 0xe7, 0x53, 0x45, 0xd6, 0x05, 0x11, 0xe8, 0xd8, 0x22, 0xf8, 0xb6, 0x18, 0xc5, 0xe8, 0xe1, 0xfa, 0x7a, 0x9d, 0xb8, 0x41, 0x01, 0x4a, 0x8a, 0x09, 0x1f, 0x7c, 0x41, 0x19]),
            crate::structs::Guardian::new([0x58, 0x07, 0x6f, 0x56, 0x1c, 0xc6, 0x2a, 0x47, 0x08, 0x7b, 0x56, 0x7c, 0x86, 0xf9, 0x86, 0x42, 0x6d, 0xfc, 0xd0, 0x00], [0xd0, 0xdd, 0xfb, 0x81, 0xee, 0xd4, 0xd5, 0xcc, 0xbb, 0x87, 0x92, 0x85, 0xc9, 0xe5, 0x26, 0x41, 0xca, 0x72, 0xcc, 0x9e, 0x89, 0xe0, 0x9b, 0x42, 0x36, 0xa1, 0x53, 0x0a, 0xbc, 0xe2, 0xd7, 0x3c], [0xfc, 0xc7, 0x2a, 0x3d, 0x05, 0xef, 0xae, 0xc4, 0x00, 0xe7, 0xec, 0xa3, 0xdc, 0xb2, 0xbb, 0x6d, 0xdf, 0x5e, 0x1f, 0x79, 0x8f, 0x8c, 0x3f, 0xa3, 0xde, 0x97, 0xfd, 0x71, 0xd4, 0xe3, 0x3a, 0xa0]),
            crate::structs::Guardian::new([0xbd, 0x6e, 0x98, 0x33, 0x49, 0x0f, 0x8f, 0xa8, 0x7c, 0x73, 0x3a, 0x18, 0x3c, 0xd0, 0x76, 0xa6, 0xcb, 0xd2, 0x90, 0x74], [0x12, 0x08, 0x13, 0x27, 0xa0, 0x56, 0x66, 0xbb, 0x31, 0x51, 0x0a, 0x69, 0x30, 0xb0, 0x5d, 0x9b, 0x10, 0x3d, 0xc3, 0x6f, 0x47, 0xbc, 0x5b, 0xbd, 0x85, 0x81, 0x62, 0xe0, 0xbd, 0xfd, 0xfc, 0x7f], [0xe9, 0x44, 0xd4, 0x06, 0xd1, 0x73, 0xa5, 0x4d, 0x57, 0x36, 0x6a, 0xae, 0x6a, 0x0c, 0xb8, 0x05, 0xea, 0x59, 0x42, 0xb7, 0x14, 0xf6, 0x4b, 0xfc, 0x05, 0x7a, 0xca, 0x35, 0xb6, 0x26, 0x59, 0x67]),
            crate::structs::Guardian::new([0xb8, 0x53, 0xfc, 0xf0, 0xa5, 0xc7, 0x8c, 0x1b, 0x56, 0xd1, 0x5f, 0xce, 0x7a, 0x15, 0x4e, 0x6e, 0xbe, 0x9e, 0xd7, 0xa2], [0x3a, 0xb8, 0x10, 0x4c, 0x4b, 0xa4, 0xb5, 0xed, 0xd1, 0x83, 0xa8, 0x09, 0x83, 0x1b, 0x1e, 0xad, 0x4f, 0x54, 0x0a, 0xb6, 0x23, 0x28, 0x10, 0x12, 0x92, 0x8b, 0xc7, 0xb2, 0x6c, 0xd1, 0xd3, 0x43], [0xe0, 0xe2, 0x81, 0x85, 0x53, 0x16, 0xbd, 0x89, 0x9f, 0x1e, 0x47, 0xa2, 0xd6, 0x3a, 0x58, 0x78, 0xac, 0x6c, 0xbb, 0xe5, 0x3a, 0x57, 0xb0, 0x3a, 0xd6, 0x64, 0xf0, 0xf1, 0xa7, 0xb7, 0xb6, 0x00]),
            crate::structs::Guardian::new([0xaf, 0x35, 0x03, 0xdb, 0xd2, 0xe3, 0x75, 0x18, 0xab, 0x04, 0xd7, 0xce, 0x78, 0xb6, 0x30, 0xf9, 0x8b, 0x15, 0xb7, 0x8a], [0x47, 0x54, 0x1e, 0x77, 0xc1, 0xff, 0xbd, 0x34, 0xed, 0x66, 0x6a, 0x2d, 0x86, 0xaa, 0x84, 0xc3, 0x72, 0xd5, 0x4c, 0x3e, 0x61, 0x1b, 0xa2, 0xbc, 0xcb, 0xcf, 0xad, 0xb5, 0xfa, 0xac, 0x5c, 0x16], [0x39, 0x5b, 0x75, 0xee, 0x6a, 0x49, 0xf9, 0xdd, 0x5a, 0x4d, 0xc2, 0xd2, 0xfd, 0xc2, 0x8e, 0x4f, 0xa7, 0x4e, 0x38, 0x8e, 0x85, 0xa6, 0x89, 0x78, 0x58, 0xff, 0x28, 0x64, 0x4b, 0x9d, 0x87, 0x84]),
            crate::structs::Guardian::new([0x78, 0x56, 0x32, 0xde, 0xa5, 0x60, 0x90, 0x64, 0x80, 0x3b, 0x1c, 0x8e, 0xa8, 0xbb, 0x2c, 0x77, 0xa6, 0x00, 0x4b, 0xd1], [0xba, 0xc0, 0x4f, 0x86, 0x0a, 0x22, 0x87, 0x40, 0x2a, 0x36, 0xda, 0xa7, 0x1e, 0xee, 0xeb, 0x46, 0x18, 0x87, 0x66, 0xf2, 0x46, 0x3a, 0x56, 0xc6, 0x84, 0x17, 0x1b, 0xd5, 0xed, 0xfb, 0xd7, 0xba], [0x3d, 0xea, 0xac, 0x57, 0x4e, 0xc0, 0x93, 0x98, 0x27, 0x86, 0x0b, 0x03, 0x1d, 0x97, 0x47, 0xd2, 0x16, 0x3c, 0xa5, 0x34, 0xa0, 0x3e, 0x84, 0x0d, 0x4c, 0xe9, 0xa4, 0xd0, 0x65, 0xff, 0x9a, 0xa6]),
            crate::structs::Guardian::new([0x09, 0xa2, 0x81, 0xa6, 0x98, 0xc0, 0xf5, 0xba, 0x31, 0xf1, 0x58, 0x58, 0x5b, 0x41, 0xf4, 0xf3, 0x36, 0x59, 0xe5, 0x4d], [0xfa, 0x0c, 0x20, 0x46, 0x33, 0x38, 0x6e, 0x43, 0x67, 0xd1, 0x0b, 0xda, 0x6a, 0x2a, 0xcd, 0x83, 0x24, 0x31, 0xc1, 0x2c, 0x7c, 0x90, 0x0a, 0xfc, 0x17, 0x45, 0xed, 0x3c, 0x75, 0x48, 0x65, 0xd3], [0x7b, 0xfe, 0xaf, 0xc6, 0x07, 0xda, 0x4b, 0x79, 0xd2, 0x0e, 0xb7, 0xb0, 0xce, 0x14, 0x9e, 0xf0, 0x95, 0x99, 0x63, 0x0c, 0x11, 0x9f, 0x8c, 0xee, 0xba, 0x27, 0x23, 0x93, 0x76, 0xcd, 0xb4, 0x50]),
            crate::structs::Guardian::new([0x31, 0x78, 0x44, 0x3a, 0xb7, 0x6a, 0x60, 0xe2, 0x16, 0x90, 0xdb, 0xfb, 0x17, 0xf7, 0xf5, 0x9f, 0x09, 0xae, 0x3e, 0xa1], [0x30, 0xb8, 0x67, 0xbd, 0xd0, 0xaf, 0x1b, 0xa2, 0x7e, 0xc3, 0x90, 0xa8, 0x5f, 0x4b, 0xce, 0x0b, 0x05, 0xfa, 0xea, 0xe6, 0x0f, 0x60, 0xae, 0x93, 0x69, 0x28, 0x16, 0x69, 0x5e, 0x5b, 0x3e, 0x33], [0xa6, 0x63, 0x7e, 0x6f, 0x90, 0xba, 0xde, 0x3f, 0xc7, 0x17, 0xe1, 0x85, 0x4f, 0x99, 0x18, 0x18, 0x28, 0xf2, 0x57, 0x98, 0xd8, 0x41, 0xc4, 0xf7, 0x8e, 0xdf, 0x67, 0x62, 0xa8, 0x91, 0xf1, 0x10]),
            crate::structs::Guardian::new([0x64, 0x7e, 0xc2, 0x6a, 0xe4, 0x9b, 0x14, 0x06, 0x06, 0x60, 0x50, 0x4f, 0x4d, 0xa1, 0xc2, 0x05, 0x9e, 0x1c, 0x5a, 0xb6], [0x83, 0xe2, 0x58, 0xec, 0xc3, 0xf9, 0xde, 0xb6, 0x89, 0x10, 0x0c, 0x83, 0x1d, 0x4d, 0xe3, 0xe7, 0x21, 0x9d, 0x6e, 0x72, 0x46, 0x6c, 0x68, 0x21, 0x48, 0xcb, 0x58, 0xf9, 0x34, 0x3b, 0x4b, 0xbd], [0x81, 0xe1, 0x1d, 0x1f, 0x33, 0xd3, 0xd4, 0xdc, 0xa0, 0x40, 0x45, 0xa5, 0x0c, 0x07, 0x1f, 0xc5, 0xbe, 0xb3, 0xf9, 0x76, 0x2f, 0xce, 0x79, 0x26, 0x0e, 0xdd, 0x75, 0x90, 0xbd, 0xdf, 0x8b, 0x7b]),
            crate::structs::Guardian::new([0x81, 0x0a, 0xc3, 0xd8, 0xe1, 0x25, 0x8b, 0xd2, 0xf0, 0x04, 0xa9, 0x4c, 0xa0, 0xcd, 0x4c, 0x68, 0xfc, 0x1c, 0x06, 0x11], [0xe7, 0xe3, 0x2b, 0xe9, 0xaf, 0x97, 0x7a, 0xd0, 0x8a, 0xa3, 0x7a, 0x1f, 0xab, 0x32, 0xca, 0x4b, 0x66, 0x89, 0x08, 0x16, 0xa9, 0x48, 0x39, 0x7e, 0x54, 0xa6, 0x3c, 0xcf, 0xa5, 0xd6, 0xd9, 0x2e], [0x00, 0x30, 0xc2, 0x87, 0x44, 0x01, 0xc8, 0x58, 0xc1, 0x71, 0x03, 0x73, 0x24, 0x6c, 0xa4, 0xe3, 0x9b, 0x8f, 0x59, 0xd3, 0x42, 0x27, 0x8e, 0x43, 0x42, 0x32, 0x1d, 0x5e, 0xb3, 0x67, 0xc5, 0x48]),
            crate::structs::Guardian::new([0x80, 0x61, 0x0e, 0x96, 0xd6, 0x45, 0xb1, 0x2f, 0x47, 0xae, 0x5c, 0xf4, 0x54, 0x6b, 0x18, 0x53, 0x87, 0x39, 0xe9, 0x0f], [0x45, 0x6d, 0xfd, 0x9d, 0x19, 0xcc, 0x9d, 0x7d, 0x64, 0x9d, 0x7a, 0x2d, 0xa1, 0x19, 0x31, 0x47, 0x15, 0x07, 0xd5, 0x6d, 0x95, 0xd0, 0x0b, 0x35, 0x1e, 0x9e, 0x5b, 0x5c, 0x52, 0x19, 0x29, 0xd1], [0x94, 0x47, 0xf0, 0xc5, 0x01, 0x77, 0x6d, 0x34, 0xbf, 0x25, 0x35, 0xa1, 0xe2, 0xb1, 0x70, 0x58, 0xb4, 0xa0, 0x16, 0xb7, 0x24, 0x37, 0x2d, 0xc4, 0xcc, 0x87, 0xa7, 0x06, 0x13, 0x99, 0xd0, 0x6f]),
            crate::structs::Guardian::new([0x2e, 0xdb, 0x0d, 0x85, 0x30, 0xe3, 0x1a, 0x21, 0x8e, 0x72, 0xb9, 0x48, 0x02, 0x02, 0xac, 0xba, 0xeb, 0x06, 0x17, 0x8d], [0xac, 0x8e, 0x60, 0xae, 0xda, 0x22, 0xb4, 0x70, 0xf6, 0x25, 0x50, 0x62, 0xff, 0x7e, 0x29, 0xfc, 0x74, 0xc2, 0x62, 0x90, 0xa7, 0x1a, 0xd6, 0xf5, 0xb6, 0xc3, 0xc5, 0xcb, 0xa2, 0x8a, 0x73, 0x4b], [0xce, 0x67, 0x33, 0x23, 0x2a, 0xeb, 0xa9, 0x31, 0xe5, 0x67, 0xb1, 0x67, 0xe5, 0x9e, 0x8b, 0x07, 0x42, 0xee, 0x16, 0x0a, 0x5e, 0xfc, 0x21, 0x2a, 0x9e, 0x66, 0xf1, 0x90, 0x1c, 0x16, 0xb3, 0x3b]),
            crate::structs::Guardian::new([0xa7, 0x88, 0x58, 0xe5, 0xe5, 0xc4, 0x70, 0x5c, 0xdd, 0x4b, 0x66, 0x8f, 0xfe, 0x3b, 0xe5, 0xba, 0xe4, 0x86, 0x7c, 0x9d], [0xb8, 0x82, 0xd0, 0xbf, 0xac, 0xa1, 0x0c, 0x6e, 0x37, 0x85, 0xc1, 0xf5, 0xe9, 0x47, 0x3f, 0xf8, 0x3c, 0x35, 0x2c, 0xbf, 0x9c, 0xa6, 0x1d, 0x0d, 0x44, 0x61, 0x3c, 0x24, 0xb8, 0x61, 0x3e, 0x01], [0x92, 0x1f, 0x32, 0x02, 0x14, 0x86, 0x47, 0x07, 0x18, 0x17, 0xac, 0x85, 0xcb, 0x84, 0x13, 0xc5, 0x57, 0x63, 0xd3, 0x4d, 0xf5, 0xc9, 0xfd, 0x66, 0x1b, 0xc6, 0x90, 0xcf, 0x59, 0x21, 0xff, 0x16]),
            crate::structs::Guardian::new([0x5e, 0xfe, 0x3a, 0x05, 0xef, 0xc6, 0x2d, 0x60, 0xe1, 0xd1, 0x9f, 0xae, 0xb5, 0x6a, 0x80, 0x22, 0x3c, 0xdd, 0x34, 0x72], [0x9a, 0xf4, 0x5b, 0x27, 0x0b, 0x79, 0xfe, 0xf7, 0xad, 0x1f, 0x97, 0xce, 0xfa, 0x09, 0xa3, 0x49, 0x22, 0x95, 0x48, 0x4c, 0x99, 0x0c, 0x3a, 0x07, 0x12, 0xcf, 0x6e, 0xe4, 0x7f, 0xe2, 0x88, 0x72], [0x87, 0x1f, 0x97, 0x13, 0x5e, 0x1e, 0xf3, 0x2a, 0xc9, 0xff, 0x2d, 0x6f, 0x4e, 0x15, 0xd0, 0x9c, 0xb2, 0x73, 0x68, 0x8a, 0x4b, 0x8c, 0xe6, 0xf8, 0x3d, 0xe1, 0x9c, 0xb8, 0xe9, 0x6d, 0xe9, 0x50]),
            crate::structs::Guardian::new([0xd7, 0x91, 0xb7, 0xd3, 0x2c, 0x05, 0xab, 0xb1, 0xcc, 0x00, 0xb6, 0x38, 0x1f, 0xa0, 0xc4, 0x92, 0x8f, 0x0c, 0x56, 0xfc], [0x0e, 0x49, 0xf3, 0xcc, 0x63, 0x85, 0x69, 0x20, 0xb9, 0xaa, 0xf9, 0x26, 0x14, 0x2c, 0x72, 0x1d, 0x2d, 0xad, 0x2a, 0x32, 0xe7, 0xe5, 0x1d, 0xf6, 0x20, 0xcf, 0x2d, 0x37, 0x9c, 0xd6, 0x2a, 0xb3], [0x73, 0x8e, 0x28, 0xf3, 0x16, 0x35, 0xcc, 0x75, 0xc6, 0xfb, 0xd1, 0x43, 0xc1, 0x0b, 0x98, 0xad, 0xc8, 0x14, 0xc6, 0x31, 0x9b, 0x81, 0xf5, 0x7c, 0x47, 0xa5, 0x55, 0xb2, 0x85, 0x76, 0x62, 0x03]),
            crate::structs::Guardian::new([0x14, 0xbc, 0x02, 0x9b, 0x88, 0x09, 0x06, 0x90, 0x93, 0xd7, 0x12, 0xa3, 0xfd, 0x4d, 0xfa, 0xb3, 0x19, 0x63, 0x59, 0x7e], [0xb2, 0x17, 0x04, 0xa6, 0xa0, 0x7d, 0xa3, 0x57, 0xc9, 0xd2, 0x37, 0x68, 0xb8, 0x89, 0xbb, 0x57, 0xa6, 0xd2, 0x20, 0xad, 0x70, 0x61, 0x5c, 0xd8, 0xb7, 0xee, 0x82, 0x3c, 0x84, 0xd7, 0x72, 0x62], [0xeb, 0x49, 0x46, 0xcb, 0xfe, 0x2e, 0x73, 0xb9, 0x65, 0xe0, 0x59, 0x19, 0xa2, 0x70, 0x5d, 0xbe, 0xa9, 0xfd, 0xf2, 0xe1, 0xbe, 0xde, 0x0b, 0xb0, 0x73, 0xfd, 0x52, 0x1f, 0xa3, 0x85, 0xcb, 0xef]),
            crate::structs::Guardian::new([0x24, 0x6a, 0xb2, 0x9f, 0xc6, 0xeb, 0xed, 0xf2, 0xd3, 0x92, 0xa5, 0x1a, 0xb2, 0xdc, 0x5c, 0x59, 0xd0, 0x90, 0x2a, 0x03], [0x53, 0xcd, 0x43, 0x54, 0xfd, 0x30, 0x6a, 0xe2, 0x1b, 0x46, 0x99, 0xdb, 0x7e, 0xeb, 0xc7, 0x4c, 0xd8, 0x5f, 0x71, 0x3a, 0x6e, 0x9a, 0x6a, 0x86, 0x14, 0xea, 0xfe, 0x61, 0x7f, 0x3b, 0x66, 0xf6], [0xa8, 0xa6, 0xb3, 0x5c, 0x35, 0xc1, 0x02, 0xe0, 0x9b, 0xcd, 0xb5, 0x19, 0xc1, 0xea, 0x9f, 0xfc, 0x9f, 0x47, 0xb7, 0xd5, 0x9b, 0x2b, 0x04, 0xfb, 0x55, 0xa1, 0x90, 0xbf, 0xa5, 0x6e, 0xc2, 0x08]),
            crate::structs::Guardian::new([0x13, 0x2a, 0x84, 0xdf, 0xd9, 0x20, 0xb3, 0x5a, 0x3d, 0x0b, 0xa5, 0xf7, 0xa0, 0x63, 0x5d, 0xf2, 0x98, 0xf9, 0x03, 0x3e], [0xad, 0x7a, 0x5a, 0xca, 0x2a, 0xa2, 0x23, 0x5c, 0xc4, 0x3e, 0x3b, 0x4f, 0x0c, 0xe6, 0x0d, 0x83, 0xc6, 0xb1, 0x7b, 0x9b, 0xbe, 0x16, 0xbd, 0xb4, 0x2b, 0xac, 0x9a, 0xad, 0x1b, 0xbb, 0x85, 0xe1], [0x9f, 0xb5, 0x12, 0x3c, 0x61, 0x02, 0xe6, 0xa0, 0xab, 0x1b, 0x64, 0x8a, 0x1d, 0xef, 0x10, 0xf4, 0x6a, 0xe3, 0x79, 0x58, 0x8a, 0x36, 0xea, 0xa4, 0x56, 0x1e, 0xed, 0x6d, 0xf0, 0xa5, 0x8c, 0xe0])
        ]
    }

    #[utility]
    unconstrained fn get_guardian_by_index_unconstrained(guardian_idx: u8, guardians: [crate::structs::Guardian; 19]) -> crate::structs::Guardian {
        if guardian_idx < 19 {
            guardians[guardian_idx as u32]
        } else {
            crate::structs::Guardian::default()
        }
    }


    #[storage]
    struct Storage<Context> {
        state: PublicMutable<WormholeStorage, Context>,
        sequences: Map<AztecAddress, PublicMutable<u64, Context>, Context>,
        wormhole_address: PublicMutable<AztecAddress, Context>,
        token_address: PublicMutable<AztecAddress, Context>,
        guardian_1: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_2: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_3: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_4: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_5: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_6: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_7: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_8: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_9: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_10: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_11: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_12: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_13: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_14: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_15: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_16: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_17: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_18: Map<u32, PublicMutable<Guardian, Context>, Context>,
        guardian_19: Map<u32, PublicMutable<Guardian, Context>, Context>,
        current_guardian_set_index: Map<u32, PublicMutable<u64, Context>, Context>,
    }

    #[public]
    #[initializer]
    fn init(
        chain_id: u16,
        evm_chain_id: u16,
        wormhole_address: AztecAddress, 
        token_address: AztecAddress, 
    ) {
        let provider: Provider = Provider {
            chain_id,
            evm_chain_id,
        };
        storage.state.write(WormholeStorage::init(provider));
        storage.wormhole_address.write(wormhole_address);
        storage.token_address.write(token_address);
        storage.current_guardian_set_index.at(0).write(18_446_744_073_709_551_615);
    }

    #[public]
    fn publish_message_in_public(
        nonce: u64,
        payloads: [[u8; 31]; 8], 
        message_fee: u128,
        consistency: u8,
        from: AztecAddress,
        token_nonce: Field,
    ) -> u64 {
        assert(storage.state.read().message_fee <= message_fee, "insufficient fee");

        let receiver_address = storage.wormhole_address.read();
        let token_address = storage.token_address.read();

        let _ = Token::at(token_address).transfer_in_public(
            from,
            receiver_address, 
            message_fee,
            token_nonce,  
        ).call(&mut context);

        let sequence = storage.sequences.at(context.msg_sender()).read();
        storage.sequences.at(context.msg_sender()).write(sequence + 1);

        let msg: [Field; 13] = [
            context.msg_sender().to_field(), 
            sequence as Field,  
            nonce as Field,
            consistency as Field, 
            context.timestamp() as Field,
            Field::from_le_bytes(payloads[0]),
            Field::from_le_bytes(payloads[1]),
            Field::from_le_bytes(payloads[2]),
            Field::from_le_bytes(payloads[3]),
            Field::from_le_bytes(payloads[4]),
            Field::from_le_bytes(payloads[5]),
            Field::from_le_bytes(payloads[6]),
            Field::from_le_bytes(payloads[7]),
        ];

        context.emit_public_log(msg);
        sequence
    }

    #[private]
    fn publish_message_in_private(
        nonce: u64,
        payloads: [[u8; 31]; 8], 
        message_fee: u128,
        consistency: u8,
        from: AztecAddress, 
        token_nonce: Field,
    ) {
        assert(1 <= message_fee, "insufficient fee");

        let receiver_address = AztecAddress {
            inner: 0x1f41267c06dae96c9c3906c5f77cbc28602cc70d6d7e9d2c3072cb0a5b13edd2
        };
        let token_address = AztecAddress {
            inner: 0x26586823af587afd741c33f0b481f47e1f7375ae6a40f4d82c5825a01f89abec
        };

        let _ = Token::at(token_address).transfer_in_private(
            from,
            receiver_address, 
            message_fee,
            token_nonce,  
        ).call(&mut context);

        Wormhole::at(context.this_address())._publish_message(
            nonce, 
            payloads, 
            consistency
        ).enqueue(&mut context);
    }

    #[public]
    #[internal]
    fn _publish_message(
        nonce: u64,
        payloads: [[u8; 31]; 8], 
        consistency: u8,
    ) -> u64 {
        let sequence = storage.sequences.at(context.msg_sender()).read();
        storage.sequences.at(context.msg_sender()).write(sequence + 1);

        let msg: [Field; 13] = [
            context.msg_sender().to_field(), 
            sequence as Field,  
            nonce as Field,
            consistency as Field, 
            context.timestamp() as Field,
            Field::from_le_bytes(payloads[0]),
            Field::from_le_bytes(payloads[1]),
            Field::from_le_bytes(payloads[2]),
            Field::from_le_bytes(payloads[3]),
            Field::from_le_bytes(payloads[4]),
            Field::from_le_bytes(payloads[5]),
            Field::from_le_bytes(payloads[6]),
            Field::from_le_bytes(payloads[7]),
        ];

        context.emit_public_log(msg);
        sequence
    }

    // Guardian setters (your existing code)
    #[public]
    fn set_guardian1(guardian: Guardian, index: u32) { 
        storage.guardian_1.at(index).write(guardian);
    }

    #[public]
    fn set_guardian2(guardian: Guardian, index: u32) { 
        storage.guardian_2.at(index).write(guardian);
    }

    #[public]
    fn set_guardian3(guardian: Guardian, index: u32) { 
        storage.guardian_3.at(index).write(guardian);
    }

    #[public]
    fn set_guardian4(guardian: Guardian, index: u32) { 
        storage.guardian_4.at(index).write(guardian);
    }

    #[public]
    fn set_guardian5(guardian: Guardian, index: u32) { 
        storage.guardian_5.at(index).write(guardian);
    }

    #[public]
    fn set_guardian6(guardian: Guardian, index: u32) { 
        storage.guardian_6.at(index).write(guardian);
    }

    #[public]
    fn set_guardian7(guardian: Guardian, index: u32) { 
        storage.guardian_7.at(index).write(guardian);
    }

    #[public]
    fn set_guardian8(guardian: Guardian, index: u32) { 
        storage.guardian_8.at(index).write(guardian);
    }

    #[public]
    fn set_guardian9(guardian: Guardian, index: u32) { 
        storage.guardian_9.at(index).write(guardian);
    }

    #[public]
    fn set_guardian10(guardian: Guardian, index: u32) { 
        storage.guardian_10.at(index).write(guardian);
    }

    #[public]
    fn set_guardian11(guardian: Guardian, index: u32) { 
        storage.guardian_11.at(index).write(guardian);
    }

    #[public]
    fn set_guardian12(guardian: Guardian, index: u32) { 
        storage.guardian_12.at(index).write(guardian);
    }

    #[public]
    fn set_guardian13(guardian: Guardian, index: u32) { 
        storage.guardian_13.at(index).write(guardian);
    }

    #[public]
    fn set_guardian14(guardian: Guardian, index: u32) { 
        storage.guardian_14.at(index).write(guardian);
    }

    #[public]
    fn set_guardian15(guardian: Guardian, index: u32) { 
        storage.guardian_15.at(index).write(guardian);
    }

    #[public]
    fn set_guardian16(guardian: Guardian, index: u32) { 
        storage.guardian_16.at(index).write(guardian);
    }

    #[public]
    fn set_guardian17(guardian: Guardian, index: u32) { 
        storage.guardian_17.at(index).write(guardian);
    }

    #[public]
    fn set_guardian18(guardian: Guardian, index: u32) { 
        storage.guardian_18.at(index).write(guardian);
    }

    #[public]
    fn set_guardian19(guardian: Guardian, index: u32) { 
        storage.guardian_19.at(index).write(guardian);
    }

    #[public]
    fn expire_guardian_set(index: u32) {
        storage.current_guardian_set_index.at(index).write(context.timestamp() + 86400);
    }

    #[public]
    fn guardian_set_expired(index: u32) -> bool {
        let timestamp = storage.current_guardian_set_index.at(index).read();
        context.timestamp() > timestamp
    }

    #[public]
    fn set_provider(provider: Provider) {
        let updated_storage = WormholeStorage::set_provider(storage.state.read(), provider);
        storage.state.write(updated_storage);
    }

    #[public]
    fn get_provider() -> Provider {
        WormholeStorage::get_provider(storage.state.read())
    }

    // Helper function to get guardian by index
    #[public]
    fn get_guardian_by_index(guardian_idx: u8, guardian_set_index: u32) -> Guardian {
        if guardian_idx == 0 { 
            storage.guardian_1.at(guardian_set_index).read()
        } else if guardian_idx == 1 { 
            storage.guardian_2.at(guardian_set_index).read()
        } else if guardian_idx == 2 { 
            storage.guardian_3.at(guardian_set_index).read()
        } else if guardian_idx == 3 { 
            storage.guardian_4.at(guardian_set_index).read()
        } else if guardian_idx == 4 { 
            storage.guardian_5.at(guardian_set_index).read()
        } else if guardian_idx == 5 { 
            storage.guardian_6.at(guardian_set_index).read()
        } else if guardian_idx == 6 { 
            storage.guardian_7.at(guardian_set_index).read()
        } else if guardian_idx == 7 { 
            storage.guardian_8.at(guardian_set_index).read()
        } else if guardian_idx == 8 { 
            storage.guardian_9.at(guardian_set_index).read()
        } else if guardian_idx == 9 { 
            storage.guardian_10.at(guardian_set_index).read()
        } else if guardian_idx == 10 { 
            storage.guardian_11.at(guardian_set_index).read()
        } else if guardian_idx == 11 { 
            storage.guardian_12.at(guardian_set_index).read()
        } else if guardian_idx == 12 { 
            storage.guardian_13.at(guardian_set_index).read()
        } else if guardian_idx == 13 { 
            storage.guardian_14.at(guardian_set_index).read()
        } else if guardian_idx == 14 { 
            storage.guardian_15.at(guardian_set_index).read()
        } else if guardian_idx == 15 { 
            storage.guardian_16.at(guardian_set_index).read()
        } else if guardian_idx == 16 { 
            storage.guardian_17.at(guardian_set_index).read()
        } else if guardian_idx == 17 { 
            storage.guardian_18.at(guardian_set_index).read()
        } else if guardian_idx == 18 { 
            storage.guardian_19.at(guardian_set_index).read()
        } else {
            Guardian::default()
        }
    }

    #[public]
    fn test_verify_signature(
        hash: [u8; 32],
        signature_r: [u8; 32],
        signature_s: [u8; 32],
        pub_key_x: [u8; 32],
        pub_key_y: [u8; 32]
    ) -> bool {
        let mut signature_bytes = [0; 64];
        for j in 0..32 {
            signature_bytes[j] = signature_r[j];
            signature_bytes[32 + j] = signature_s[j];
        }
        
        std::ecdsa_secp256k1::verify_signature(
            pub_key_x,
            pub_key_y,
            signature_bytes,
            hash
        )
    }

    // VAA verification function
    #[private]
    fn verify_vaa(bytes: [u8; 1918]) {
        // Parse VAA components
        let version = bytes[0];
        assert(version == 1, "Unsupported version");
        
        let _guardian_set_index: u32 = crate::structs::u32_from_u8s_le([bytes[1], bytes[2], bytes[3], bytes[4]]);
        let signatures_len = bytes[5];
        assert(signatures_len == 13, "Too many signatures");

        let mut signatures: [Signature; 13] = [Signature::default(); 13];
        
        // Parse signatures
        for i in 0..13 {
            if i < 13 {
                let sig_start: u32 = 6 + (i as u32 * 66);
                let mut sig_bytes = [0; 66];
                for j in 0..66 {
                    let byte_index: u32 = sig_start + j as u32;
                    if byte_index < 1918 {
                        sig_bytes[j] = bytes[byte_index];
                    }
                }
                signatures[i as u32] = Signature::from_bytes(sig_bytes);
            }
        }

        // Calculate body start and extract body
        let body_start: u32 = 6 + (signatures_len as u32 * 66);
        let mut body_bytes = [0; 1060];
        for i in 0..1060 {
            let byte_index: u32 = body_start + i as u32;
            if byte_index < 1918 {
                body_bytes[i] = bytes[byte_index];
            }
        }

        // Calculate hash: keccak256(keccak256(body))
        let hash1: [u8; 32] = keccak256(body_bytes, 1060);
        let hash: [u8; 32] = keccak256(hash1, 32);

        // Safety: is not unconstrained, verified later
        let guardians = unsafe {
            get_hardcoded_guardians()
        };

        // Verify signatures
        let mut last_idx: u8 = 0;
        let mut verification_result = true;
        let mut valid_signatures = 0;

        for i in 0..13 {
            let sig = signatures[i];
            
            // Skip empty signatures
            let is_empty_sig = (i > 0) & (sig.guardian_index == 0);
            
            if !is_empty_sig {
                let guardian_idx = sig.guardian_index;

                // Check ascending order
                if guardian_idx <= last_idx {
                    verification_result = false;
                }
                last_idx = guardian_idx;

                // Check bounds
                if guardian_idx >= 19 {
                    verification_result = false;
                }

                if guardian_idx < 19 {
                    // Safety: is not unconstrained, verified later
                    let guardian = unsafe {
                        get_guardian_by_index_unconstrained(guardian_idx, guardians)
                    };

                    let pub_key_x = guardian.get_pub_key_x();
                    let pub_key_y = guardian.get_pub_key_y();

                    // Prepare signature bytes
                    let mut signature_bytes = [0; 64];
                    for j in 0..32 {
                        signature_bytes[j] = sig.r[j];
                        signature_bytes[32 + j] = sig.s[j];
                    }

                    // Verify signature
                    // Safety: ECDSA verification moved to unconstrained for Aztec compatibility
                    let is_valid = std::ecdsa_secp256k1::verify_signature(
                        pub_key_x,
                        pub_key_y,
                        signature_bytes,
                        hash
                    );
                    if is_valid {
                        valid_signatures += 1;
                    } else {
                        verification_result = false;
                    }
                }
            }
        }

        // Need at least 2/3 + 1 of guardians to sign (13 out of 19)
        let required_signatures = 13;
        if valid_signatures < required_signatures {
            verification_result = false;
        }

        assert(verification_result);
    }

    #[test]
    fn test_verify_vaa_real_data() {
        let mut full_vaa = [0; 1918];
        
        // First VAA data from your examples
        full_vaa[0] = 1; full_vaa[1] = 0; full_vaa[2] = 0; full_vaa[3] = 0; full_vaa[4] = 0;
        full_vaa[5] = 1; full_vaa[6] = 0; full_vaa[7] = 8; full_vaa[8] = 31; full_vaa[9] = 44;
        full_vaa[10] = 132; full_vaa[11] = 235; full_vaa[12] = 49; full_vaa[13] = 251; full_vaa[14] = 25;
        full_vaa[15] = 234; full_vaa[16] = 63; full_vaa[17] = 1; full_vaa[18] = 97; full_vaa[19] = 100;
        full_vaa[20] = 140; full_vaa[21] = 68; full_vaa[22] = 125; full_vaa[23] = 134; full_vaa[24] = 215;
        full_vaa[25] = 123; full_vaa[26] = 215; full_vaa[27] = 9; full_vaa[28] = 5; full_vaa[29] = 98;
        full_vaa[30] = 181; full_vaa[31] = 136; full_vaa[32] = 128; full_vaa[33] = 18; full_vaa[34] = 234;
        full_vaa[35] = 28; full_vaa[36] = 127; full_vaa[37] = 132; full_vaa[38] = 197; full_vaa[39] = 96;
        full_vaa[40] = 133; full_vaa[41] = 80; full_vaa[42] = 81; full_vaa[43] = 3; full_vaa[44] = 64;
        full_vaa[45] = 34; full_vaa[46] = 16; full_vaa[47] = 197; full_vaa[48] = 249; full_vaa[49] = 195;
        full_vaa[50] = 250; full_vaa[51] = 88; full_vaa[52] = 13; full_vaa[53] = 109; full_vaa[54] = 99;
        full_vaa[55] = 40; full_vaa[56] = 164; full_vaa[57] = 69; full_vaa[58] = 56; full_vaa[59] = 76;
        full_vaa[60] = 67; full_vaa[61] = 168; full_vaa[62] = 230; full_vaa[63] = 192; full_vaa[64] = 53;
        full_vaa[65] = 221; full_vaa[66] = 86; full_vaa[67] = 238; full_vaa[68] = 133; full_vaa[69] = 43;
        full_vaa[70] = 127; full_vaa[71] = 1; full_vaa[72] = 104; full_vaa[73] = 85; full_vaa[74] = 97;
        full_vaa[75] = 95; full_vaa[76] = 104; full_vaa[77] = 85; full_vaa[78] = 97; full_vaa[79] = 94;
        full_vaa[80] = 0; full_vaa[81] = 2; full_vaa[82] = 0; full_vaa[83] = 0; full_vaa[84] = 0;
        full_vaa[85] = 0; full_vaa[86] = 0; full_vaa[87] = 0; full_vaa[88] = 0; full_vaa[89] = 0;
        full_vaa[90] = 0; full_vaa[91] = 0; full_vaa[92] = 0; full_vaa[93] = 0; full_vaa[94] = 144;
        full_vaa[95] = 248; full_vaa[96] = 191; full_vaa[97] = 106; full_vaa[98] = 71; full_vaa[99] = 159;
        full_vaa[100] = 50; full_vaa[101] = 14; full_vaa[102] = 173; full_vaa[103] = 7; full_vaa[104] = 68;
        full_vaa[105] = 17; full_vaa[106] = 164; full_vaa[107] = 176; full_vaa[108] = 231; full_vaa[109] = 148;
        full_vaa[110] = 78; full_vaa[111] = 168; full_vaa[112] = 201; full_vaa[113] = 193; full_vaa[114] = 0;
        full_vaa[115] = 0; full_vaa[116] = 0; full_vaa[117] = 0; full_vaa[118] = 0; full_vaa[119] = 0;
        full_vaa[120] = 0; full_vaa[121] = 9; full_vaa[122] = 200; full_vaa[123] = 0; full_vaa[124] = 0;
        full_vaa[125] = 0; full_vaa[126] = 0; full_vaa[127] = 0; full_vaa[128] = 0; full_vaa[129] = 0;
        full_vaa[130] = 0; full_vaa[131] = 0; full_vaa[132] = 0; full_vaa[133] = 0; full_vaa[134] = 0;
        full_vaa[135] = 0; full_vaa[136] = 0; full_vaa[137] = 0; full_vaa[138] = 0; full_vaa[139] = 0;
        full_vaa[140] = 0; full_vaa[141] = 0; full_vaa[142] = 0; full_vaa[143] = 0; full_vaa[144] = 0;
        full_vaa[145] = 0; full_vaa[146] = 0; full_vaa[147] = 0; full_vaa[148] = 0; full_vaa[149] = 0;
        full_vaa[150] = 0; full_vaa[151] = 0; full_vaa[152] = 0; full_vaa[153] = 0; full_vaa[154] = 0;
        full_vaa[155] = 32; full_vaa[156] = 0; full_vaa[157] = 0; full_vaa[158] = 0; full_vaa[159] = 0;
        full_vaa[160] = 0; full_vaa[161] = 0; full_vaa[162] = 0; full_vaa[163] = 0; full_vaa[164] = 0;
        full_vaa[165] = 0; full_vaa[166] = 0; full_vaa[167] = 0; full_vaa[168] = 0; full_vaa[169] = 0;
        full_vaa[170] = 0; full_vaa[171] = 0; full_vaa[172] = 0; full_vaa[173] = 0; full_vaa[174] = 0;
        full_vaa[175] = 0; full_vaa[176] = 0; full_vaa[177] = 0; full_vaa[178] = 0; full_vaa[179] = 0;
        full_vaa[180] = 0; full_vaa[181] = 0; full_vaa[182] = 0; full_vaa[183] = 0; full_vaa[184] = 0;
        full_vaa[185] = 0; full_vaa[186] = 0; full_vaa[187] = 14; full_vaa[188] = 72; full_vaa[189] = 101;
        full_vaa[190] = 108; full_vaa[191] = 108; full_vaa[192] = 111; full_vaa[193] = 32; full_vaa[194] = 87;
        full_vaa[195] = 111; full_vaa[196] = 114; full_vaa[197] = 109; full_vaa[198] = 104; full_vaa[199] = 111;
        
        // Test basic parsing
        assert(full_vaa[0] == 1); // version
        assert(full_vaa[5] == 1); // signatures_len
        
        // If you made verify_vaa public, uncomment this line:
        // verify_vaa(full_vaa);
    }

    #[test]
    fn test_verify_vaa_parsing() {
        let mut full_vaa = [0; 1918];
        
        // First VAA data from your examples
        full_vaa[0] = 1; full_vaa[1] = 0; full_vaa[2] = 0; full_vaa[3] = 0; full_vaa[4] = 0;
        full_vaa[5] = 1; full_vaa[6] = 0; full_vaa[7] = 8; full_vaa[8] = 31; full_vaa[9] = 44;
        full_vaa[10] = 132; full_vaa[11] = 235; full_vaa[12] = 49; full_vaa[13] = 251; full_vaa[14] = 25;
        full_vaa[15] = 234; full_vaa[16] = 63; full_vaa[17] = 1; full_vaa[18] = 97; full_vaa[19] = 100;
        full_vaa[20] = 140; full_vaa[21] = 68; full_vaa[22] = 125; full_vaa[23] = 134; full_vaa[24] = 215;
        full_vaa[25] = 123; full_vaa[26] = 215; full_vaa[27] = 9; full_vaa[28] = 5; full_vaa[29] = 98;
        full_vaa[30] = 181; full_vaa[31] = 136; full_vaa[32] = 128; full_vaa[33] = 18; full_vaa[34] = 234;
        full_vaa[35] = 28; full_vaa[36] = 127; full_vaa[37] = 132; full_vaa[38] = 197; full_vaa[39] = 96;
        full_vaa[40] = 133; full_vaa[41] = 80; full_vaa[42] = 81; full_vaa[43] = 3; full_vaa[44] = 64;
        full_vaa[45] = 34; full_vaa[46] = 16; full_vaa[47] = 197; full_vaa[48] = 249; full_vaa[49] = 195;
        full_vaa[50] = 250; full_vaa[51] = 88; full_vaa[52] = 13; full_vaa[53] = 109; full_vaa[54] = 99;
        full_vaa[55] = 40; full_vaa[56] = 164; full_vaa[57] = 69; full_vaa[58] = 56; full_vaa[59] = 76;
        full_vaa[60] = 67; full_vaa[61] = 168; full_vaa[62] = 230; full_vaa[63] = 192; full_vaa[64] = 53;
        full_vaa[65] = 221; full_vaa[66] = 86; full_vaa[67] = 238; full_vaa[68] = 133; full_vaa[69] = 43;
        full_vaa[70] = 127; full_vaa[71] = 1; full_vaa[72] = 104; full_vaa[73] = 85; full_vaa[74] = 97;
        full_vaa[75] = 95; full_vaa[76] = 104; full_vaa[77] = 85; full_vaa[78] = 97; full_vaa[79] = 94;
        full_vaa[80] = 0; full_vaa[81] = 2; full_vaa[82] = 0; full_vaa[83] = 0; full_vaa[84] = 0;
        full_vaa[85] = 0; full_vaa[86] = 0; full_vaa[87] = 0; full_vaa[88] = 0; full_vaa[89] = 0;
        full_vaa[90] = 0; full_vaa[91] = 0; full_vaa[92] = 0; full_vaa[93] = 0; full_vaa[94] = 144;
        full_vaa[95] = 248; full_vaa[96] = 191; full_vaa[97] = 106; full_vaa[98] = 71; full_vaa[99] = 159;
        full_vaa[100] = 50; full_vaa[101] = 14; full_vaa[102] = 173; full_vaa[103] = 7; full_vaa[104] = 68;
        full_vaa[105] = 17; full_vaa[106] = 164; full_vaa[107] = 176; full_vaa[108] = 231; full_vaa[109] = 148;
        full_vaa[110] = 78; full_vaa[111] = 168; full_vaa[112] = 201; full_vaa[113] = 193; full_vaa[114] = 0;
        full_vaa[115] = 0; full_vaa[116] = 0; full_vaa[117] = 0; full_vaa[118] = 0; full_vaa[119] = 0;
        full_vaa[120] = 0; full_vaa[121] = 9; full_vaa[122] = 200; full_vaa[123] = 0; full_vaa[124] = 0;
        full_vaa[125] = 0; full_vaa[126] = 0; full_vaa[127] = 0; full_vaa[128] = 0; full_vaa[129] = 0;
        full_vaa[130] = 0; full_vaa[131] = 0; full_vaa[132] = 0; full_vaa[133] = 0; full_vaa[134] = 0;
        full_vaa[135] = 0; full_vaa[136] = 0; full_vaa[137] = 0; full_vaa[138] = 0; full_vaa[139] = 0;
        full_vaa[140] = 0; full_vaa[141] = 0; full_vaa[142] = 0; full_vaa[143] = 0; full_vaa[144] = 0;
        full_vaa[145] = 0; full_vaa[146] = 0; full_vaa[147] = 0; full_vaa[148] = 0; full_vaa[149] = 0;
        full_vaa[150] = 0; full_vaa[151] = 0; full_vaa[152] = 0; full_vaa[153] = 0; full_vaa[154] = 0;
        full_vaa[155] = 32; full_vaa[156] = 0; full_vaa[157] = 0; full_vaa[158] = 0; full_vaa[159] = 0;
        full_vaa[160] = 0; full_vaa[161] = 0; full_vaa[162] = 0; full_vaa[163] = 0; full_vaa[164] = 0;
        full_vaa[165] = 0; full_vaa[166] = 0; full_vaa[167] = 0; full_vaa[168] = 0; full_vaa[169] = 0;
        full_vaa[170] = 0; full_vaa[171] = 0; full_vaa[172] = 0; full_vaa[173] = 0; full_vaa[174] = 0;
        full_vaa[175] = 0; full_vaa[176] = 0; full_vaa[177] = 0; full_vaa[178] = 0; full_vaa[179] = 0;
        full_vaa[180] = 0; full_vaa[181] = 0; full_vaa[182] = 0; full_vaa[183] = 0; full_vaa[184] = 0;
        full_vaa[185] = 0; full_vaa[186] = 0; full_vaa[187] = 14; full_vaa[188] = 72; full_vaa[189] = 101;
        full_vaa[190] = 108; full_vaa[191] = 108; full_vaa[192] = 111; full_vaa[193] = 32; full_vaa[194] = 87;
        full_vaa[195] = 111; full_vaa[196] = 114; full_vaa[197] = 109; full_vaa[198] = 104; full_vaa[199] = 111;
        
        
        let version = full_vaa[0];
        assert(version == 1, "Unsupported version");
        
        let _guardian_set_index: u32 = crate::structs::u32_from_u8s_le([full_vaa[1], full_vaa[2], full_vaa[3], full_vaa[4]]);
        let signatures_len = full_vaa[5];
        assert(signatures_len == 1, "Expected 1 signature from test data on wormhole locally");
        
        let mut signatures: [Signature; 13] = [Signature::default(); 13];
        
        // Parse signatures exactly like verify_vaa does
        for i in 0..13 {
            if i < 13 {
                let sig_start: u32 = 6 + (i as u32 * 66);
                let mut sig_bytes = [0; 66];
                for j in 0..66 {
                    let byte_index: u32 = sig_start + j as u32;
                    if byte_index < 1918 {
                        sig_bytes[j] = full_vaa[byte_index];
                    }
                }
                signatures[i as u32] = Signature::from_bytes(sig_bytes);
            }
        }
        
        // Test that we parsed the signature correctly
        let first_sig = signatures[0];
        // Don't assume which guardian - just check it's valid
        assert(first_sig.guardian_index < 19, "Guardian index should be valid (0-18)");
        
        // Test body extraction
        let body_start: u32 = 6 + (signatures_len as u32 * 66);
        let mut body_bytes = [0; 1060];
        for i in 0..1060 {
            let byte_index: u32 = body_start + i as u32;
            if byte_index < 1918 {
                body_bytes[i] = full_vaa[byte_index];
            }
        }
        
        // Test hash calculation
        let hash1: [u8; 32] = keccak256(body_bytes, 1060);
        let hash: [u8; 32] = keccak256(hash1, 32);
        
        // Verify we got a hash (not all zeros)
        let mut hash_is_zero = true;
        for i in 0..32 {
            if hash[i] != 0 {
                hash_is_zero = false;
            }
        }
        assert(!hash_is_zero, "Hash should not be all zeros");
        
        assert(true);
    }

    #[test]
    fn test_verify_vaa_real_data_2() {
        let mut full_vaa = [0; 1918];
        
        // Second VAA data from your examples
        full_vaa[0] = 1; full_vaa[1] = 0; full_vaa[2] = 0; full_vaa[3] = 0; full_vaa[4] = 0;
        full_vaa[5] = 1; full_vaa[6] = 0; full_vaa[7] = 22; full_vaa[8] = 70; full_vaa[9] = 215;
        full_vaa[10] = 147; full_vaa[11] = 85; full_vaa[12] = 159; full_vaa[13] = 119; full_vaa[14] = 93;
        full_vaa[15] = 49; full_vaa[16] = 25; full_vaa[17] = 137; full_vaa[18] = 121; full_vaa[19] = 94;
        full_vaa[20] = 29; full_vaa[21] = 78; full_vaa[22] = 170; full_vaa[23] = 59; full_vaa[24] = 120;
        full_vaa[25] = 207; full_vaa[26] = 204; full_vaa[27] = 154; full_vaa[28] = 26; full_vaa[29] = 119;
        full_vaa[30] = 103; full_vaa[31] = 14; full_vaa[32] = 142; full_vaa[33] = 182; full_vaa[34] = 129;
        full_vaa[35] = 20; full_vaa[36] = 210; full_vaa[37] = 201; full_vaa[38] = 144; full_vaa[39] = 16;
        full_vaa[40] = 184; full_vaa[41] = 210; full_vaa[42] = 173; full_vaa[43] = 3; full_vaa[44] = 148;
        full_vaa[45] = 160; full_vaa[46] = 243; full_vaa[47] = 151; full_vaa[48] = 212; full_vaa[49] = 207;
        full_vaa[50] = 157; full_vaa[51] = 159; full_vaa[52] = 208; full_vaa[53] = 25; full_vaa[54] = 168;
        full_vaa[55] = 25; full_vaa[56] = 45; full_vaa[57] = 138; full_vaa[58] = 39; full_vaa[59] = 232;
        full_vaa[60] = 195; full_vaa[61] = 223; full_vaa[62] = 142; full_vaa[63] = 230; full_vaa[64] = 129;
        full_vaa[65] = 77; full_vaa[66] = 92; full_vaa[67] = 129; full_vaa[68] = 253; full_vaa[69] = 64;
        full_vaa[70] = 105; full_vaa[71] = 0; full_vaa[72] = 104; full_vaa[73] = 85; full_vaa[74] = 97;
        full_vaa[75] = 82; full_vaa[76] = 104; full_vaa[77] = 85; full_vaa[78] = 97; full_vaa[79] = 81;
        full_vaa[80] = 0; full_vaa[81] = 2; full_vaa[82] = 0; full_vaa[83] = 0; full_vaa[84] = 0;
        full_vaa[85] = 0; full_vaa[86] = 0; full_vaa[87] = 0; full_vaa[88] = 0; full_vaa[89] = 0;
        full_vaa[90] = 0; full_vaa[91] = 0; full_vaa[92] = 0; full_vaa[93] = 0; full_vaa[94] = 144;
        full_vaa[95] = 248; full_vaa[96] = 191; full_vaa[97] = 106; full_vaa[98] = 71; full_vaa[99] = 159;
        full_vaa[100] = 50; full_vaa[101] = 14; full_vaa[102] = 173; full_vaa[103] = 7; full_vaa[104] = 68;
        full_vaa[105] = 17; full_vaa[106] = 164; full_vaa[107] = 176; full_vaa[108] = 231; full_vaa[109] = 148;
        full_vaa[110] = 78; full_vaa[111] = 168; full_vaa[112] = 201; full_vaa[113] = 193; full_vaa[114] = 0;
        full_vaa[115] = 0; full_vaa[116] = 0; full_vaa[117] = 0; full_vaa[118] = 0; full_vaa[119] = 0;
        full_vaa[120] = 0; full_vaa[121] = 8; full_vaa[122] = 200; full_vaa[123] = 0; full_vaa[124] = 0;
        full_vaa[125] = 0; full_vaa[126] = 0; full_vaa[127] = 0; full_vaa[128] = 0; full_vaa[129] = 0;
        full_vaa[130] = 0; full_vaa[131] = 0; full_vaa[132] = 0; full_vaa[133] = 0; full_vaa[134] = 0;
        full_vaa[135] = 0; full_vaa[136] = 0; full_vaa[137] = 0; full_vaa[138] = 0; full_vaa[139] = 0;
        full_vaa[140] = 0; full_vaa[141] = 0; full_vaa[142] = 0; full_vaa[143] = 0; full_vaa[144] = 0;
        full_vaa[145] = 0; full_vaa[146] = 0; full_vaa[147] = 0; full_vaa[148] = 0; full_vaa[149] = 0;
        full_vaa[150] = 0; full_vaa[151] = 0; full_vaa[152] = 0; full_vaa[153] = 0; full_vaa[154] = 0;
        full_vaa[155] = 32; full_vaa[156] = 0; full_vaa[157] = 0; full_vaa[158] = 0; full_vaa[159] = 0;
        full_vaa[160] = 0; full_vaa[161] = 0; full_vaa[162] = 0; full_vaa[163] = 0; full_vaa[164] = 0;
        full_vaa[165] = 0; full_vaa[166] = 0; full_vaa[167] = 0; full_vaa[168] = 0; full_vaa[169] = 0;
        full_vaa[170] = 0; full_vaa[171] = 0; full_vaa[172] = 0; full_vaa[173] = 0; full_vaa[174] = 0;
        full_vaa[175] = 0; full_vaa[176] = 0; full_vaa[177] = 0; full_vaa[178] = 0; full_vaa[179] = 0;
        full_vaa[180] = 0; full_vaa[181] = 0; full_vaa[182] = 0; full_vaa[183] = 0; full_vaa[184] = 0;
        full_vaa[185] = 0; full_vaa[186] = 0; full_vaa[187] = 14; full_vaa[188] = 72; full_vaa[189] = 101;
        full_vaa[190] = 108; full_vaa[191] = 108; full_vaa[192] = 111; full_vaa[193] = 32; full_vaa[194] = 87;
        full_vaa[195] = 111; full_vaa[196] = 114; full_vaa[197] = 109; full_vaa[198] = 104; full_vaa[199] = 111;
        
        // Test basic parsing
        assert(full_vaa[0] == 1); // version
        assert(full_vaa[5] == 1); // signatures_len
    }

    #[test]
    fn test_verify_vaa_parsing_2() {
        let mut full_vaa = [0; 1918];
        
        // Second VAA data from your examples
        full_vaa[0] = 1; full_vaa[1] = 0; full_vaa[2] = 0; full_vaa[3] = 0; full_vaa[4] = 0;
        full_vaa[5] = 1; full_vaa[6] = 0; full_vaa[7] = 22; full_vaa[8] = 70; full_vaa[9] = 215;
        full_vaa[10] = 147; full_vaa[11] = 85; full_vaa[12] = 159; full_vaa[13] = 119; full_vaa[14] = 93;
        full_vaa[15] = 49; full_vaa[16] = 25; full_vaa[17] = 137; full_vaa[18] = 121; full_vaa[19] = 94;
        full_vaa[20] = 29; full_vaa[21] = 78; full_vaa[22] = 170; full_vaa[23] = 59; full_vaa[24] = 120;
        full_vaa[25] = 207; full_vaa[26] = 204; full_vaa[27] = 154; full_vaa[28] = 26; full_vaa[29] = 119;
        full_vaa[30] = 103; full_vaa[31] = 14; full_vaa[32] = 142; full_vaa[33] = 182; full_vaa[34] = 129;
        full_vaa[35] = 20; full_vaa[36] = 210; full_vaa[37] = 201; full_vaa[38] = 144; full_vaa[39] = 16;
        full_vaa[40] = 184; full_vaa[41] = 210; full_vaa[42] = 173; full_vaa[43] = 3; full_vaa[44] = 148;
        full_vaa[45] = 160; full_vaa[46] = 243; full_vaa[47] = 151; full_vaa[48] = 212; full_vaa[49] = 207;
        full_vaa[50] = 157; full_vaa[51] = 159; full_vaa[52] = 208; full_vaa[53] = 25; full_vaa[54] = 168;
        full_vaa[55] = 25; full_vaa[56] = 45; full_vaa[57] = 138; full_vaa[58] = 39; full_vaa[59] = 232;
        full_vaa[60] = 195; full_vaa[61] = 223; full_vaa[62] = 142; full_vaa[63] = 230; full_vaa[64] = 129;
        full_vaa[65] = 77; full_vaa[66] = 92; full_vaa[67] = 129; full_vaa[68] = 253; full_vaa[69] = 64;
        full_vaa[70] = 105; full_vaa[71] = 0; full_vaa[72] = 104; full_vaa[73] = 85; full_vaa[74] = 97;
        full_vaa[75] = 82; full_vaa[76] = 104; full_vaa[77] = 85; full_vaa[78] = 97; full_vaa[79] = 81;
        full_vaa[80] = 0; full_vaa[81] = 2; full_vaa[82] = 0; full_vaa[83] = 0; full_vaa[84] = 0;
        full_vaa[85] = 0; full_vaa[86] = 0; full_vaa[87] = 0; full_vaa[88] = 0; full_vaa[89] = 0;
        full_vaa[90] = 0; full_vaa[91] = 0; full_vaa[92] = 0; full_vaa[93] = 0; full_vaa[94] = 144;
        full_vaa[95] = 248; full_vaa[96] = 191; full_vaa[97] = 106; full_vaa[98] = 71; full_vaa[99] = 159;
        full_vaa[100] = 50; full_vaa[101] = 14; full_vaa[102] = 173; full_vaa[103] = 7; full_vaa[104] = 68;
        full_vaa[105] = 17; full_vaa[106] = 164; full_vaa[107] = 176; full_vaa[108] = 231; full_vaa[109] = 148;
        full_vaa[110] = 78; full_vaa[111] = 168; full_vaa[112] = 201; full_vaa[113] = 193; full_vaa[114] = 0;
        full_vaa[115] = 0; full_vaa[116] = 0; full_vaa[117] = 0; full_vaa[118] = 0; full_vaa[119] = 0;
        full_vaa[120] = 0; full_vaa[121] = 8; full_vaa[122] = 200; full_vaa[123] = 0; full_vaa[124] = 0;
        full_vaa[125] = 0; full_vaa[126] = 0; full_vaa[127] = 0; full_vaa[128] = 0; full_vaa[129] = 0;
        full_vaa[130] = 0; full_vaa[131] = 0; full_vaa[132] = 0; full_vaa[133] = 0; full_vaa[134] = 0;
        full_vaa[135] = 0; full_vaa[136] = 0; full_vaa[137] = 0; full_vaa[138] = 0; full_vaa[139] = 0;
        full_vaa[140] = 0; full_vaa[141] = 0; full_vaa[142] = 0; full_vaa[143] = 0; full_vaa[144] = 0;
        full_vaa[145] = 0; full_vaa[146] = 0; full_vaa[147] = 0; full_vaa[148] = 0; full_vaa[149] = 0;
        full_vaa[150] = 0; full_vaa[151] = 0; full_vaa[152] = 0; full_vaa[153] = 0; full_vaa[154] = 0;
        full_vaa[155] = 32; full_vaa[156] = 0; full_vaa[157] = 0; full_vaa[158] = 0; full_vaa[159] = 0;
        full_vaa[160] = 0; full_vaa[161] = 0; full_vaa[162] = 0; full_vaa[163] = 0; full_vaa[164] = 0;
        full_vaa[165] = 0; full_vaa[166] = 0; full_vaa[167] = 0; full_vaa[168] = 0; full_vaa[169] = 0;
        full_vaa[170] = 0; full_vaa[171] = 0; full_vaa[172] = 0; full_vaa[173] = 0; full_vaa[174] = 0;
        full_vaa[175] = 0; full_vaa[176] = 0; full_vaa[177] = 0; full_vaa[178] = 0; full_vaa[179] = 0;
        full_vaa[180] = 0; full_vaa[181] = 0; full_vaa[182] = 0; full_vaa[183] = 0; full_vaa[184] = 0;
        full_vaa[185] = 0; full_vaa[186] = 0; full_vaa[187] = 14; full_vaa[188] = 72; full_vaa[189] = 101;
        full_vaa[190] = 108; full_vaa[191] = 108; full_vaa[192] = 111; full_vaa[193] = 32; full_vaa[194] = 87;
        full_vaa[195] = 111; full_vaa[196] = 114; full_vaa[197] = 109; full_vaa[198] = 104; full_vaa[199] = 111;
        
        let version = full_vaa[0];
        assert(version == 1, "Unsupported version");
        
        let _guardian_set_index: u32 = crate::structs::u32_from_u8s_le([full_vaa[1], full_vaa[2], full_vaa[3], full_vaa[4]]);
        let signatures_len = full_vaa[5];
        assert(signatures_len == 1, "Expected 1 signature from test data on wormhole locally");
        
        let mut signatures: [Signature; 13] = [Signature::default(); 13];
        
        // Parse signatures exactly like verify_vaa does
        for i in 0..13 {
            if i < 13 {
                let sig_start: u32 = 6 + (i as u32 * 66);
                let mut sig_bytes = [0; 66];
                for j in 0..66 {
                    let byte_index: u32 = sig_start + j as u32;
                    if byte_index < 1918 {
                        sig_bytes[j] = full_vaa[byte_index];
                    }
                }
                signatures[i as u32] = Signature::from_bytes(sig_bytes);
            }
        }
        
        // Test that we parsed the signature correctly
        let first_sig = signatures[0];
        // Don't assume which guardian - just check it's valid
        assert(first_sig.guardian_index < 19, "Guardian index should be valid (0-18)");
        
        // Test body extraction
        let body_start: u32 = 6 + (signatures_len as u32 * 66);
        let mut body_bytes = [0; 1060];
        for i in 0..1060 {
            let byte_index: u32 = body_start + i as u32;
            if byte_index < 1918 {
                body_bytes[i] = full_vaa[byte_index];
            }
        }
        
        // Test hash calculation
        let hash1: [u8; 32] = keccak256(body_bytes, 1060);
        let hash: [u8; 32] = keccak256(hash1, 32);
        
        // Verify we got a hash (not all zeros)
        let mut hash_is_zero = true;
        for i in 0..32 {
            if hash[i] != 0 {
                hash_is_zero = false;
            }
        }
        assert(!hash_is_zero, "Hash should not be all zeros");
        
        assert(true);
    }
}